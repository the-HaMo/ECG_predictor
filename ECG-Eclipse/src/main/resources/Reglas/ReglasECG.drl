//created on: 23 oct 2025
package Reglas
import Clases.*
import java.util.ArrayList

//list any import classes here.



//declare any global variables here

/*
rule "Imprimir"
    when
        $o: Onda() 
    then
        System.out.println($o);
end
*/ 

rule "Detectar Ciclo cardíaco con T"
when
    // Ondas secuenciales no usadas
    $p: Onda_P(usada == false, $startP: start)

    $q: Onda_Q(usada == false, $startQ: start)
        eval($startQ > $startP)
        not Onda_Q(usada == false, start > $startP && start < $startQ)

    $r: Onda_R(usada == false, $startR: start)
        eval($startR > $startQ)
        not Onda_R(usada == false, start > $startQ && start < $startR)

    $s: Onda_S(usada == false, $startS: start, $endS: fin)
        eval($startS > $startR)
        not Onda_S(usada == false, start > $startR && start < $startS)

    // Existe una T inmediatamente después de la S
    $t: Onda_T(usada == false, $startT: start, $endT: fin)
        eval($startT > $startS)
        not Onda_T(usada == false, start > $startS && start < $startT)
then
    int finCiclo = $endT;
    int duracion = finCiclo - $startQ;

    insert(new Ciclo_Cardiaco(duracion));

    System.out.println("Ciclo cardíaco detectado (con T): desde " +
        $startQ + "ms hasta " + finCiclo + "ms. Duración: " + duracion);

    // Marcar ondas como usadas
    modify($p) { setUsada(); }
    modify($q) { setUsada(); }
    modify($r) { setUsada(); }
    modify($s) { setUsada(); }
    modify($t) { setUsada(); }
end


rule "Detectar Ciclo cardíaco sin T"
when
    // Ondas secuenciales no usadas
    $p: Onda_P($startP: start)

    $q: Onda_Q($startQ: start)
        eval($startQ > $startP)
        not Onda_Q(start > $startP && start < $startQ)

    $r: Onda_R(usada == false, $startR: start)
        eval($startR > $startQ)
        not Onda_R(usada == false, start > $startQ && start < $startR)

    $s: Onda_S(usada == false, $startS: start, $endS: fin)
        eval($startS > $startR)
        not Onda_S(usada == false, start > $startR && start < $startS)

    // No hay T después de S
    not Onda_T(usada == false, start > $startS)
then
    int finCiclo = $endS;
    int duracion = finCiclo - $startQ;

    insert(new Ciclo_Cardiaco(duracion));

    System.out.println("Ciclo cardíaco detectado (sin T): desde " +
        $startQ + "ms hasta " + finCiclo + "ms. Duración: " + duracion);

    // Marcar ondas como usadas
    modify($p) { setUsada(); }
    modify($q) { setUsada(); }
    modify($r) { setUsada(); }
    modify($s) { setUsada(); }
end


// Cálculo de número de ciclos y ritmo cardíaco
rule "Numero de ciclos y ritmo cardiaco"
when
    $listaCiclos : java.util.List() from collect( Ciclo_Cardiaco() )
    $listaQ : java.util.List() from collect( Onda_Q() )
    eval( !$listaCiclos.isEmpty() )
    eval( !$listaQ.isEmpty() )
then
    int numCiclos = $listaCiclos.size();
 
    // Tomamos la primera(ultima insertada) y última (primera insertada) Q
    Onda_Q ultimaQ = (Onda_Q) $listaQ.get(0);
    Onda_Q primeraQ  = (Onda_Q) $listaQ.get($listaQ.size() - 1);

    int duracionTotal = ultimaQ.getStart() - primeraQ.getStart();

    // Fórmula exacta según la práctica
    int ritmo_cardiaco = (60000 * numCiclos) / duracionTotal;
    insert(new Analisis_Señal(numCiclos, ritmo_cardiaco));

    System.out.println("Num_cycles : " + numCiclos);
    System.out.println("Heart_Rate : " + ritmo_cardiaco + " pul/min");
end

rule "Creacion Complejo_QRS"
when
    // Ondas en orden secuencial natural (sin usada)
    $q: Onda_Q($startQ: start, $endQ: fin, $peakQ: peak)
    
    $r: Onda_R($startR: start, $endR: fin, $peakR: peak)
        eval($startR > $endQ)
        not Onda_R(start > $endQ && start < $startR)
    
    $s: Onda_S($startS: start, $endS: fin, $peakS: peak)
        eval($startS > $endR)
        not Onda_S(start > $endR && start < $startS)
    
    // Duración fisiológica típica del complejo QRS: 60–200 ms
    eval(($endS - $startQ) >= 60 && ($endS - $startQ) <= 200)
then
    int duracion = $endS - $startQ;
    double amplitudTotal = $peakR - Math.min($peakQ, $peakS);

    insert(new Complejo_QRS($q, $r, $s, duracion));

    System.out.println(
        "Complejo QRS detectado: inicio=" + $startQ + 
        "ms, fin=" + $endS + "ms, duración=" + duracion + 
        "ms, amplitud=" + amplitudTotal
    );
end


/*
rule "Creacion Intervalo PR"
    when
        $p: Onda_P(usada == true, $startP: start)
        $q: Onda_Q(usada == true, $startQ: start, start > $p.fin)
        
        // Q debe estar cerca de P (mismo ciclo) e intervalo PR tipico es < 400ms
        eval($startQ - $startP < 400) 
        not(Intervalo_PR(inicio == $startP, fin == $startQ))
    then
        int duracion = $startQ - $startP;
        Intervalo_PR intervaloPR = new Intervalo_PR($startP, $startQ, duracion);
        insert(intervaloPR);
        System.out.println("Intervalo PR: " + $startP + " -> " + $startQ + " | Duración: " + duracion + "ms");
end

rule "Crear Intervalo QT"
    when
        $q: Onda_Q(usada == true, $startQ: start)
        $t: Onda_T(usada == true, $startT: start, $endT: fin, start > $q.fin)
        
        // T debe estar cerca de Q (mismo ciclo) e Intervalo QT típico < 600ms
        eval($endT - $startQ < 600)  
        not(Intervalo_QT(inicio == $startQ, fin == $endT))
    then
        int duracion = $endT - $startQ;
        Intervalo_QT intervaloQT = new Intervalo_QT($startQ, $endT, duracion);
        insert(intervaloQT);
        System.out.println("Intervalo QT: " + $startQ + " -> " + $endT + " | Duración: " + duracion + "ms");
end

rule "Crear Segmento PR"
    when
        $p: Onda_P(usada == true, $endP: fin)
        $q: Onda_Q(usada == true, $startQ: start, start > $endP)
        
        // Verificar que están en el mismo ciclo
        eval($startQ - $endP < 200)
        not(Segmento_PR(inicio == $endP, fin == $startQ))
    then
        int duracion = $startQ - $endP;
        Segmento_PR segmentoPR = new Segmento_PR($endP, $startQ, 0.0, duracion);
        insert(segmentoPR);
        System.out.println("Segmento PR: " + $endP + " -> " + $startQ + " | Duración: " + duracion + "ms");
end

rule "Crear Segmento ST"
    when
        $s: Onda_S(usada == true, $endS: fin)
        $t: Onda_T(usada == true, $startT: start, start > $endS)
        
        // Verificar que están en el mismo ciclo
        eval($startT - $endS < 300)
        not(Segmento_ST(inicio == $endS, fin == $startT))
    then
        int duracion = $startT - $endS;
        Segmento_ST segmentoST = new Segmento_ST($endS, $startT, 0.0, duracion);
        insert(segmentoST);
        System.out.println("Segmento ST: " + $endS + " -> " + $startT +"| Duración: " + duracion + "ms");
end
*/
