//created on: 23 oct 2025
package Reglas
import Clases.*
import java.util.ArrayList
import java.util.List


//list any import classes here.



//declare any global variables here

/*
rule "Imprimir"
    when
        $o: Onda() 
    then
        System.out.println($o);
end
*/ 

rule "Detectar Ciclo cardíaco con T"
when
    // Ondas secuenciales en orden temporal
    $p: Onda_P($startP: start)

    $q: Onda_Q($startQ: start)
        eval($startQ > $startP)
        not Onda_Q(start > $startP && start < $startQ)

    $r: Onda_R($startR: start)
        eval($startR > $startQ)
        not Onda_R(start > $startQ && start < $startR)

    $s: Onda_S($startS: start, $endS: fin)
        eval($startS > $startR)
        not Onda_S(start > $startR && start < $startS)

    // T inmediatamente posterior a S (la primera después de S)
    $t: Onda_T($startT: start, $endT: fin)
        eval($startT > $startS)
        not Onda_T(start > $startS && start < $startT)
then
    int finCiclo = $endT;
    int duracion = finCiclo - $startQ;

    insert(new Ciclo_Cardiaco(duracion));

    //System.out.println( "Ciclo cardíaco detectado (con T): desde " +  $startQ + "ms hasta " + finCiclo + "ms. Duración: " + duracion );
    
end

rule "Detectar Ciclo cardíaco sin T"
when
    $p: Onda_P($startP: start)

    $q: Onda_Q($startQ: start)
        eval($startQ > $startP)
        not Onda_Q(start > $startP && start < $startQ)

    $r: Onda_R($startR: start)
        eval($startR > $startQ)
        not Onda_R(start > $startQ && start < $startR)

    $s: Onda_S($startS: start, $endS: fin)
        eval($startS > $startR)
        not Onda_S(start > $startR && start < $startS)

    // No existe una onda T posterior a S
    not Onda_T(start > $startS)
then
    int finCiclo = $endS;
    int duracion = finCiclo - $startQ;

    insert(new Ciclo_Cardiaco(duracion));

    //System.out.println( "Ciclo cardíaco detectado (sin T): desde " + $startQ + "ms hasta " + finCiclo +   "ms. Duración: " + duracion);
end


// Cálculo de número de ciclos y ritmo cardíaco
rule "Numero de ciclos y ritmo cardiaco"
when
    $listaCiclos : java.util.List() from collect( Ciclo_Cardiaco() )
    $listaQ : java.util.List() from collect( Onda_Q() )
    eval( !$listaCiclos.isEmpty() )
    eval( !$listaQ.isEmpty() )
then
    int numCiclos = $listaCiclos.size();
 
    // Tomamos la primera(ultima insertada) y última (primera insertada) Q
    Onda_Q ultimaQ = (Onda_Q) $listaQ.get(0);
    Onda_Q primeraQ  = (Onda_Q) $listaQ.get($listaQ.size() - 1);

    int duracionTotal = ultimaQ.getStart() - primeraQ.getStart();

    // Fórmula exacta según la práctica
    int ritmo_cardiaco = (60000 * numCiclos) / duracionTotal;
    insert(new Analisis_Señal(numCiclos, ritmo_cardiaco));

   // System.out.println("Num_cycles : " + numCiclos);
   // System.out.println("Heart_Rate : " + ritmo_cardiaco + " pul/min");
end

rule "Creacion Complejo_QRS"
when
    $q: Onda_Q($startQ: start, $endQ: fin, $peakQ: peak)
    
    $r: Onda_R($startR: start, $endR: fin, $peakR: peak)
        eval($startR >= $endQ) // la mas cercana
    
    $s: Onda_S($startS: start, $endS: fin, $peakS: peak)
        eval($startS >= $endR)
    
    eval(($endS - $startQ) <= 120)
    not(Complejo_QRS( q == $q, r == $r, s == $s )) // comprobar que el complejo QRS ya no exista
then
    int duracion = $endS - $startQ;
    double amplitudTotal = $peakR - Math.min($peakQ, $peakS);

    insert(new Complejo_QRS($q, $r, $s, duracion)); 
	//System.out.println("Complejo QRS detectado: inicio=" + $startQ +  "ms, fin=" + $endS + "ms, duración=" + duracion + "ms, amplitud=" + amplitudTotal );
end

rule "Crear Intervalo QT" // A lo mejor es necesario el peak
when
    $q: Onda_Q($startQ: start, $endQ: fin)
    $t: Onda_T($startT: start, $endT: fin)
        eval($startT > $endQ)
        not(Onda_T(start > $endQ && start < $startT))
    // Duración fisiológica típica del QT < 600 ms
    eval(($endT - $startQ) < 600)
    // Evitar duplicados
    not(Intervalo_QT(inicio == $startQ, fin == $endT))
then
    int duracion = $endT - $startQ;
    Intervalo_QT intervaloQT = new Intervalo_QT($startQ, $endT, duracion);
    insert(intervaloQT);

    //System.out.println("Intervalo QT detectado: inicio=" + $startQ + "ms, fin=" + $endT +"ms, duración=" + duracion + "ms");
end


rule "Crear Segmento ST"
when
    $s: Onda_S($endS: fin, $peakS: peak)
    $t: Onda_T($startT: start, $endT: fin, $peakT: peak)
        eval($startT > $endS)
        // Garantizar que sea la PRIMERA T tras la S
        not(Onda_T(start > $endS && start < $startT))
    // Verificar que pertenecen al mismo ciclo cardíaco
    eval($startT - $endS < 300)
    // Evitar duplicados
    not(Segmento_ST(inicio == $endS, fin == $startT))
then
    int duracion = $startT - $endS;
    double amplitudST = ($peakT + $peakS) / 2.0; // media de las dos
    Segmento_ST segmentoST = new Segmento_ST($endS, $startT, amplitudST, duracion);
    insert(segmentoST);
    System.out.println("Segmento ST detectado: inicio=" + $endS + "ms, fin=" + $startT + "ms, duración=" + duracion + "ms, amplitud media=" + amplitudST);
end


rule "Detectar Taquicardia"
when
    $analisis : Analisis_Señal($ritmo : ritmo_cardiaco)
        eval($ritmo > 100)
then
    System.out.println(
        "Taquicardia detectada: Ritmo cardíaco = " + 
        $ritmo + " pul/min"
    );

    // Insertamos un objeto de resultado si deseas registrar el diagnóstico
    insert(new Diagnostico_Inferido(Diagnostico.TAQUICARDIA_SINUSAL));
end

rule "Detectar Braquicardia"
when
    $analisis : Analisis_Señal($ritmo : ritmo_cardiaco)
        eval($ritmo < 60 )
then
    System.out.println(
        "Braquicardia detectada: Ritmo cardíaco = " + 
        $ritmo + " pul/min"
    );

    // Insertamos un objeto de resultado si deseas registrar el diagnóstico
    insert(new Diagnostico_Inferido(Diagnostico.BRADICARDIA_SINUSAL));
end


rule "Detectar Hipopotasemia"
when
    $ts : List() from collect(Onda_T($peak: peak))
    $sts : List() from collect(Segmento_ST($amp: amplitud))
    $analisis : Analisis_Señal($ritmo: ritmo_cardiaco)
then
    double sumaT = 0;
    for (Object tObj : $ts) {
        Onda_T t = (Onda_T) tObj;
        sumaT += t.getPeak();
    }
    double mediaT = sumaT / $ts.size();

    double sumaST = 0;
    for (Object stObj : $sts) {
        Segmento_ST st = (Segmento_ST) stObj;
        sumaST += st.getAmplitud();
    }
    double mediaST = sumaST / $sts.size();

    // Hipopotasemia: T muy negativa y ST deprimido
    if (mediaT < -12 && mediaST < -0.5 && $ritmo <= 100) {
        System.out.println("Hipopotasemia detectada: Media T=" + mediaT + ", Media ST=" + mediaST + ", Ritmo=" + $ritmo);
        insert(new Diagnostico_Inferido(Diagnostico.HIPOPOTASEMIA));
    }
end

rule "Detectar Infarto Agudo de Miocardio Temprano"
when
    // Q ancha (>40 ms)
    $q : Onda_Q($durQ : fin - start)
        eval($durQ > 40)

    // Segmento ST (para referencia temporal)
    $st : Segmento_ST($endS : fin)

    // T anormal (alta o invertida) cercana a fin de ST
    $t : Onda_T($startT : start, $peakT : peak)
        eval($startT < ($endS + 40))
        eval($peakT > 0.6)

    // Evita repetir diagnóstico si ya se insertó uno con ese resultado
    not(Diagnostico_Inferido(resultados contains Diagnostico.INFARTO_AGUDO_MIOCARDIO))
then
    System.out.println("Infarto Agudo de Miocardio (temprano) detectado: " +
        "T anormal (peak=" + $peakT + "), Q ancha (" + $durQ + " ms)");

    insert(new Diagnostico_Inferido(Diagnostico.INFARTO_AGUDO_MIOCARDIO));
end


rule "Detectar Hipocalcemia"
when
	$qt : Intervalo_QT( $duracionQT : fin - start )
		eval($duracionQT >440)
	$st : Segmento_ST($duracionST : fin -start)
		eval($duracionST <80)
	not(Diagnostico_Inferido(resultados contains Diagnostico.HIPOCALCEMIA))
then
	System.out.println("Hipocalcemia detectada: QT prolongado (" + $duracionQT + 
       " ms), ST corto (" + $duracionST + " ms)");

    insert(new Diagnostico_Inferido(Diagnostico.INFARTO_AGUDO_MIOCARDIO));
end



/*
// CREO QUE NO HACE FALTA
rule "Creacion Intervalo PR"
    when
        $p: Onda_P(usada == true, $startP: start)
        $q: Onda_Q(usada == true, $startQ: start, start > $p.fin)
        
        // Q debe estar cerca de P (mismo ciclo) e intervalo PR tipico es < 400ms
        eval($startQ - $startP < 400) 
        not(Intervalo_PR(inicio == $startP, fin == $startQ))
    then
        int duracion = $startQ - $startP;
        Intervalo_PR intervaloPR = new Intervalo_PR($startP, $startQ, duracion);
        insert(intervaloPR);
        System.out.println("Intervalo PR: " + $startP + " -> " + $startQ + " | Duración: " + duracion + "ms");
end

rule "Crear Segmento PR"
    when
        $p: Onda_P(usada == true, $endP: fin)
        $q: Onda_Q(usada == true, $startQ: start, start > $endP)
        
        // Verificar que están en el mismo ciclo
        eval($startQ - $endP < 200)
        not(Segmento_PR(inicio == $endP, fin == $startQ))
    then
        int duracion = $startQ - $endP;
        Segmento_PR segmentoPR = new Segmento_PR($endP, $startQ, 0.0, duracion);
        insert(segmentoPR);
        System.out.println("Segmento PR: " + $endP + " -> " + $startQ + " | Duración: " + duracion + "ms");
end
*/
